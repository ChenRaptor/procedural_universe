<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Sphère C++ + WebGL</title>
  <style>canvas { display: block; margin: 20px auto; background: #222; }</style>
</head>
<body>
  <canvas id="glcanvas" width="640" height="480"></canvas>
  <script src="sphere.js"></script>
  <script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');
    if (!gl) alert('WebGL non supporté');

    // Compilation shaders et création programme WebGL
    function compileShader(src, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(vsSource, fsSource) {
      const vs = compileShader(vsSource, gl.VERTEX_SHADER);
      const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        alert(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec3 vNormal;
      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
        vNormal = aNormal;
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vNormal;
      void main() {
        vec3 light = normalize(vec3(0.5, 0.7, 1.0));
        float brightness = max(dot(normalize(vNormal), light), 0.0);
        vec3 color = vec3(0.2, 0.5, 1.0) * brightness + vec3(0.1);
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const program = createProgram(vsSource, fsSource);

    // Fonctions de matrices 4x4 (projection et vue)
    function perspectiveMatrix(fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ]);
    }

    function lookAt(eye, center, up) {
      const f = normalize(subtract(center, eye));
      const s = normalize(cross(f, up));
      const u = cross(s, f);
      return new Float32Array([
        s[0], u[0], -f[0], 0,
        s[1], u[1], -f[1], 0,
        s[2], u[2], -f[2], 0,
        -dot(s, eye), -dot(u, eye), dot(f, eye), 1
      ]);
    }

    function subtract(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; }
    function normalize(v) {
      const len = Math.hypot(...v);
      return v.map(x => x / len);
    }
    function cross(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0],
      ];
    }
    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    Module().then(Module => {
      // Génère la sphère en C++
      Module._generateSphere(1.0, 30, 30);

      const vertexCount = Module._getVertexCount();
      const indexCount = Module._getIndexCount();

      const verticesPtr = Module._getVertices();
      const normalsPtr = Module._getNormals();
      const indicesPtr = Module._getIndices();

      // Récupère les données depuis WASM (mem partagée)
      const vertices = new Float32Array(Module.HEAPF32.buffer, verticesPtr, vertexCount * 3);
      const normals = new Float32Array(Module.HEAPF32.buffer, normalsPtr, vertexCount * 3);
      const indices = new Uint16Array(Module.HEAPU16.buffer, indicesPtr, indexCount);

      // Buffers WebGL
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      gl.useProgram(program);

      const aPosition = gl.getAttribLocation(program, 'aPosition');
      const aNormal = gl.getAttribLocation(program, 'aNormal');
      const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
      const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

      gl.enableVertexAttribArray(aPosition);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(aNormal);
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

      const projectionMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
      const modelViewMatrix = lookAt([0, 0, 4], [0, 0, 0], [0, 1, 0]);

      gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
      gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);

      gl.clearColor(0.1, 0.1, 0.1, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
    });
  </script>
</body>
</html>
